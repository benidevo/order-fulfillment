package com.orderfulfillment.command.repositories.impl;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.orderfulfillment.command.domain.EventMessage;
import com.orderfulfillment.command.domain.Order;
import com.orderfulfillment.command.events.Event;
import com.orderfulfillment.command.exceptions.ConcurrencyException;
import com.orderfulfillment.command.repositories.OrderRepository;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import lombok.extern.slf4j.Slf4j;
import org.apache.kafka.clients.admin.NewTopic;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Repository;

/**
 * This repository manages the persistence of Order aggregates and their events, providing methods
 * to retrieve orders by ID and save order changes.
 *
 * <p>This implementation is responsible for:
 *
 * <ul>
 *   <li>Loading an order's state by replaying its event history
 *   <li>Saving new events generated by order operations
 *   <li>Publishing events to the event store
 *   <li>Ensuring optimistic concurrency control
 * </ul>
 */
@Slf4j
@Repository
public class OrderRepositoryImpl implements OrderRepository {
  private final KafkaTemplate<String, Object> kafkaTemplate;
  private final NewTopic topic;
  private final ObjectMapper objectMapper;
  private final Map<String, List<Event<?>>> eventStore = new HashMap<>();

  public OrderRepositoryImpl(
      KafkaTemplate<String, Object> kafkaTemplate, NewTopic topic, ObjectMapper objectMapper) {
    this.kafkaTemplate = kafkaTemplate;
    this.topic = topic;
    this.objectMapper = objectMapper;
  }

  public Order findById(String orderId) {
    List<Event<?>> events = eventStore.getOrDefault(orderId, new ArrayList<>());
    if (events.isEmpty()) {
      return null;
    }

    Order order = new Order();
    order.loadFromHistory(events);
    return order;
  }

  public void save(Order order) {
    List<Event<?>> currentEvents = eventStore.getOrDefault(order.getId(), new ArrayList<>());
    long expectedVersion = currentEvents.size();

    if (order.getVersion() != expectedVersion && !currentEvents.isEmpty()) {
      log.error(
          "Concurrency conflict for order {}: expected version {}, but found {}",
          order.getId(),
          expectedVersion,
          order.getVersion());
      throw new ConcurrencyException(
          "Expected version " + expectedVersion + " but found " + order.getVersion());
    }

    List<Event<?>> uncommittedEvents = order.getUncommittedChanges();
    List<CompletableFuture<?>> futures = new ArrayList<>();

    for (Event<?> event : uncommittedEvents) {
      EventMessage message = createEventMessage(event, event.getPayload());

      log.info("Publishing event {} to topic {}", event.getEventId(), topic.name());
      futures.add(
          kafkaTemplate.send(topic.name(), event.getAggregateId(), message).toCompletableFuture());

      if (!eventStore.containsKey(order.getId())) {
        eventStore.put(order.getId(), new ArrayList<>());
      }
      eventStore.get(order.getId()).add(event);
    }

    CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
    log.info("Order {} saved with {} events", order.getId(), uncommittedEvents.size());
    order.markChangesAsCommitted();
  }

  /**
   * Creates an event message for publishing to the event store.
   *
   * <p>This method converts an event object to a serialized EventMessage by serializing the event
   * payload to JSON format.
   *
   * @param event The domain event containing metadata such as ID, type, and aggregate information
   * @param payload The payload object to be serialized into JSON
   * @return An EventMessage containing all event metadata and the serialized payload
   * @throws RuntimeException if the payload cannot be serialized to JSON
   */
  private EventMessage createEventMessage(Event<?> event, Object payload) {
    String payloadJson;
    try {
      payloadJson = objectMapper.writeValueAsString(payload);
    } catch (JsonProcessingException e) {
      log.error("Error serializing payload for event {}", event.getEventId(), e);
      throw new RuntimeException("Failed to serialize event payload", e);
    }

    return new EventMessage(
        event.getEventId(),
        event.getEventType(),
        event.getAggregateId(),
        event.getAggregateType(),
        event.getTimestamp().toString(),
        payloadJson);
  }
}
